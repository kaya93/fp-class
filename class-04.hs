{-
  Все задачи в этом задании должны решаться исключительно с помощью свёрток.
  Явная рекурсия не допускается. Если в решении в качестве вспомогательной
  требуется стандартная функция обработки списков (помимо fold*, scan*), она
  также должна реализовываться свёрткой.

  Каждое решение должно сопровождаться тремя различными тестовыми примерами, которые при запуске
  возвращают True, например:

  f = undefined -- решение 
  f_test1 = f undefined == undefined -- тест 1
  f_test2 = f undefined == undefined -- тест 2
  f_test3 = f undefined == undefined -- тест 3
-}

{-
 1. Простейшие функции обработки списков
  a) Найти сумму чётных элементов списка с целочисленными элементами.
  b) Найти сумму и произведение элементов списка вещественных чисел.
  с) Найти среднее арифметическое элементов списка вещественных чисел (функцией length пользоваться нельзя,
     решение должно выполняться в один проход).
  d) Найти минимальный элемент списка.
  e) Найти наименьший нечётный элемент списка с целочисленными значениями (дополнительным параметром
     функции должно быть значение, возвращаемое по умолчанию).
-}
import Data.List
import Data.Char
import Numeric

f1a = foldl (\c x -> c + if (even x) then x else 0) 0
f1a_test1 = f1a [1,2,3,4,5,67,7,45,34] == 40
f1a_test2 = f1a [1,3,5] == 0
f1a_test3 = f1a [2,4,6] == 12

f1b = foldl(\(c,p) x -> (c+x,p*x)) (0,1)
f1b_test1 = f1b [1,2,3,4] == (10,24)
f1b_test2 = f1b [0] == (0,0)
f1b_test3 = f1b [4,10] == (14,40)

f1c list = s/k
	where (s,k) = foldl (\(s,k) x -> (s+x,k+1)) (0,0) list
f1c_test1 = f1c [1,2,3,4,5] == 3
f1c_test2 = f1c [23,31,45] == 33
f1c_test3 = f1c [1,2,6] == 3

f1d = foldl (\min x -> if x<min then x else min) 9223372036854775807
f1d_test1 = f1d [1,2,3,4,5,6] == 1
f1d_test2 = f1d [5,3,6,2,8,2,8,3,2] == 2
f1d_test3 = f1d [456,5756,234,732,782332,823] == 234

f1e list def = if min == (maxBound :: Int) then def else min
	where
	  min = foldl (\min x -> if x < min && odd x then x else min) (maxBound :: Int) list
f1e_test1 = f1e [2,46,56,6,22] (-1) == -1
f1e_test2 = f1e [1,2,3,4,5] 45 == 1
f1e_test3 = f1e [-3,45,7,-35,56] 333 == -35

{-
 2. Свёртки, формирующие списки
  a) Сформировать список, содержащий каждый второй элемент исходного.
  b) Сформировать список, содержащий первые n элементов исходного.
  c) Сформировать список, содержащий последние n элементов исходного.
  d) Сформировать список, содержащий все элементы исходного списка, большие левого соседа.
  e) Сформировать список, содержащий все локальные минимумы исходного списка.
  f) Дана строка, содержащая слова, разделённые одним или несколькими пробелами. Сформировать
     список слов этой строки.
  g) Разбить список на непересекающиеся подсписки длиной n элементов.
  h) Разбить список на подсписки длиной n элементов с перекрывающейся частью в k элементов (k < n).
  k) Сформировать список, содержащий все начальные элементы списка, удовлетворяющие заданному предикату.
  l) Повторить каждый элемент списка заданное количество раз.
  m) Удалить из списка повторяющиеся подряд идущие элементы.
  n) Даны два списка одинаковой длины. Сформировать список, состоящий из результатов применения
     заданной функции двух аргументов к соответствующим элементам исходных списков.
-}
f2a list = fst $ foldr (\x (acc, c) -> (if even c then x : acc else acc, c + 1)) ([], 0) list
f2a_test1 = f2a [1,2,3,4] == [2,4] 
f2a_test2 = null $ f2a []
f2a_test3 = f2a [0] == [0]

reverse' = foldl (\acc x -> x:acc) []

f2b list n = reverse' $ fst $ foldr (\x (acc, c) -> (if c<n then x : acc else acc, c+1)) ([], 0) (reverse' list)
f2b_test1 = f2b [1,2,3,4] 3 == [1,2,3]
f2b_test2 = f2b [0] 3 == [0]
f2b_test3 = null $ f2b [] 0

f2c list n = fst $ foldr (\x (acc, c) -> (if c<n then x : acc else acc, c+1)) ([], 0) list
f2c_test1 = f2c [1,2,3,4] 3 == [2,3,4]
f2c_test2 = f2c [0] 3 == [0]
f2c_test3 = null $ f2c [] 0

f2d list = fst $ foldr (\x (acc, r) -> (if x<r then r : acc else acc, x)) ([], minBound :: Int) list
f2d_test1 = f2d [1,2,3,4,5] == [2,3,4,5]
f2d_test2 = null $ f2d []
f2d_test3 = f2d [0] == [] 
{- суть: накапливаем в acc результат, в r находится правый сосед (из предыдущего применения свертки, а в x - тот самый левый сосед (текущий элемент). Сравниваем их, и если правый сосед больше (как требует условие), то добавляем его в список. Здесь используется правая свертка, т.к. вычисления идут с правой стороны списка -}

f2e list = fst $ foldr(\xl (acc, (x, xr)) -> (if x<xl && x<xr then x : acc else acc, (xl,x))) ([], (minBound :: Int, minBound :: Int)) list
f2e_test1 = f2e [1,2,3,4] == []
f2e_test2 = null $ f2d []
f2e_test3 = f2e [4,3,5,2,8,9] == [3,2]
{- суть: как и в прошлом задании, только теперь мы накапливаем 2 переменнные, а текущая становится самой левой, первая же из накопленных - средней. Сравниваем, если подходит, записываем в список. -}

f2f = foldr (\x_c (x:xs) -> if x_c == ' ' then if x == [] then (x:xs) else ([]:x:xs) else (([x_c]++x):xs)) [[]]
f2f_test1 = f2f "sds sdsd asca" == ["sds", "sdsd", "asca"]
f2f_test2 = f2f "" == [""]
f2f_test3 = f2f "sds" == ["sds"]
{- суть: здесь аккумулятором является список списков. Просматриваем список справа. Если текущий символ равен ' ', то если голова списка - это пустой список, то оставляем его без изменения, если же список не пуст, до открываем в списке свисков новый пусток список для записи нового слова. Иначе продолжаем запись в уже открытый список текущего слова, пока не наступил пробел. -}

f2g list k = f
	where 
	  (f,s) = foldr (\x_c ((x:xs),n) -> if n == k-1 then if x == [] then ((([x_c]++x):xs),0) else (([x_c]:x:xs),0) else ((([x_c]++x):xs),n+1)) ([[]],0) list
f2g_test1 = f2g "asdfgvhbhbhfkfirjflvldmfkf" 2 == ["as","df","gv","hb","hb","hf","kf","ir","jf","lv","ld","mf","kf"]
f2g_test2 = f2g "adfgvnfjfdd" 0 == [""]
f2g_test3 = f2g "" 5 == [""]
{-Суть: как и в f2f, но там не учитываем пробелы, а здесь учитываем все символы -}

f2h :: [a] -> Int-> Int-> [[a]]
f2h [] n k = []
f2h xs n k = (f2b n xs):(if length xs - n +k >= 0 then (f2h (f2c xs (length xs - n + k )) n k) else [])

f2k pred = foldr f2k' []  -- левая свертка, т.к. идем с начала списка
	where f2k' x acc
	         | pred x = x:acc  -- если удовлетворяет предикату - присоединяем
	         | otherwise = []  -- если нет, останавливаемся и прекращаем формировать список
f2k_test1 = f2k (<5) [1,2,3,4,5,6,7,8,9,0] == [1,2,3,4]
f2k_test2 = f2k (even) [2,4,3,4,2] == [2,4]
f2k_test3 = f2k (odd) [1,2,3,4,5,6,7,8,9,0] == [1]

f2l n list = foldr (\x acc -> ((f2l' x) ++ acc)) [] list -- множим элементы и формируем список
	where
	  f2l' x = foldl (\acc i -> x:acc) [] [1..n] -- работае как цикл от 1 до n (похоже на
						     -- concat.replicate)
f2l_test1 = null $ f2l 0 [1,2,3]
f2l_test2 = f2l 1 [1,2,3] == [1,2,3]
f2l_test3 = f2l 2 [1,2,3] == [1,1,2,2,3,3]

f2m (y:ys) = reverse' $ foldl (\(x:xs) x0 -> if x0 == x then (x:xs) else (x0:x:xs)) [y] ys
f2m_test1 = f2m [1,2,2,3,3,3] == [1,2,3]
f2m_test2 = f2m [1,2,3] == [1,2,3]
f2m_test3 = f2m [1,2,2,3,3,3,2,2,1] == [1,2,3,2,1]

 {-3. Использование свёртки как носителя рекурсии (для запуска свёртки можно использовать список типа [1..n]).
  a) Найти сумму чисел от a до b.
  b) Найти сумму факториалов чисел от a до b (повторные вычисления факториалов не допускаются).
  с) Сформировать список из первых n чисел Фибоначчи.
  d) Пользуясь рядом Тейлора, вычислить значение синуса заданного числа x (использовать
     n слагаемых).
  e) Проверить, является ли заданное целое число простым.
-}

f3a a b = foldl1 (+) [a..b]

fact x 
	| x == 0 = 1
	| otherwise = foldl1 (*) [1..x]
f3b a b = fst $ foldl (\(acc, x0) x -> (x*x0 + acc, x*x0)) (fact a, fact a) [a+1..b]
{- Суть: факториал выполняем сверткой с непустым начальным значением. Аккумулятором для суммы факториалов будет пара типа (текущая сумма, текущее значение факториала). На каждом шаге свертки вычисляем новое значение суммы и новое значение факториала) -}

f3c n = reverse' $ fst $ foldl (\(acc, x1) x -> ([x+x1]++acc,x)) ([1,1],1) [1..n-2]

f3e n = foldl (\acc x -> (n `mod` x /= 0)&&acc) True [2..(ceiling $ sqrt $ fromIntegral n)]
--fromIntegral тут нужен для того чтобы превратить n в Num, чтобы компилятор не ругался на литерал `2'.
-- Суть: второй параметр свертки - список чисел, на которые надо поделить
-- чтобы проверить, простое число или нет. Инфу, как обычно копим в аккумуляторе. Тут она булевская.


{-
 4. Решить задачу о поиске пути с максимальной суммой в треугольнике (см. лекцию 3) при условии,
   что необходимо дополнительно найти сам путь (к примеру, в виде закодированных направлений спуска:
   0 - влево, 1 - вправо). В решении допускается использование любых стандартных функций.
-}

{-
 5. Пусть числовые матрицы представлены списками строк. Реализовать следующие функции:
  1) транспонирование матрицы;
  2) сумма двух матриц;
  3) произведение двух матриц.
-}

length' = foldr (\_ count -> count + 1) 0
fst_elems = foldl (\acc (x:_) -> acc ++ [x]) [] --выдает первые элементы всех строк матрицы (1 столбик)
lst_elems = foldl (\acc (_:xs) -> acc ++ [xs]) [] -- выдает все столбцы матриц, кроме 1
f51 list = fst $ foldl (\(res, rest) _ -> (res ++ [fst_elems rest], lst_elems rest)) ([], list) [1..length' list]
f51_test1 = f51 [[1]] == [[1]]
f51_test2 = f51 [[1,2],[3,4]] == [[1,3],[2,4]]
f51_test3 = f51 [[1,2,3],[4,5,6],[7,8,9]] == [[1,4,7],[2,5,8],[3,6,9]]
 {-суть: каждую итерацию вытягивает первый столбик остатка матрицы и делает его строкой конструируемого списка. Так до тех пор, пока от матрицы исходной не останется список пустых списков. -}

sum_list l1 l2 = fst $ foldl (\(res, ((x:xs), (y:ys))) _ -> (res ++ [x+y], (xs, ys))) ([], (l1, l2)) [1..length' l1]
f52 l1 l2 = fst $ foldl (\(res, ((x:xs), (y:ys))) _ -> (res ++ [sum_list x y] , (xs, ys))) ([], (l1, l2)) [1..length' l1]
{-суть: просто берем строки матриц и поэлементно складываем -}

foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl' f a bs = foldr (\b g x -> g (f x b)) id bs a

{-
 6. Реализовать левую свёртку, пользуясь правой. Проанализировать поведение собственной реализации
  на бесконечных списках и сравнить его с поведением оригинальной foldl.
-}
